import {
  appendParams
} from "./chunk-3JLAXBDU.js";
import {
  DEFAULT_VERSION
} from "./chunk-RE3PXSSL.js";
import {
  Source_default
} from "./chunk-S4UXG74J.js";
import {
  ERROR_THRESHOLD,
  Triangulation_default,
  calculateSourceResolution,
  render
} from "./chunk-ESZIPBQH.js";
import {
  compareVersions,
  equivalent,
  get,
  transform
} from "./chunk-NBFMABG5.js";
import {
  ImageBase_default,
  Image_default
} from "./chunk-RCAQKSI7.js";
import {
  ImageState_default
} from "./chunk-5TDNKDLD.js";
import {
  EventType_default,
  Event_default,
  abstract,
  listen,
  unlistenByKey
} from "./chunk-K4RVNEPZ.js";
import {
  linearFindNearest
} from "./chunk-3MMGXAX3.js";
import {
  containsExtent,
  equals,
  getCenter,
  getForViewAndSize,
  getHeight,
  getIntersection,
  getWidth
} from "./chunk-H4C7RZEK.js";
import {
  assert
} from "./chunk-VXW2LBXG.js";
import {
  ceil,
  floor,
  round
} from "./chunk-PAQUSFNP.js";

// node_modules/ol/reproj/Image.js
var ReprojImage = class extends ImageBase_default {
  constructor(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate) {
    const maxSourceExtent = sourceProj.getExtent();
    const maxTargetExtent = targetProj.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    const targetCenter = getCenter(limitedTargetExtent);
    const sourceResolution = calculateSourceResolution(
      sourceProj,
      targetProj,
      targetCenter,
      targetResolution
    );
    const errorThresholdInPixels = ERROR_THRESHOLD;
    const triangulation = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    const sourceExtent = triangulation.calculateSourceExtent();
    const sourceImage = getImageFunction(
      sourceExtent,
      sourceResolution,
      pixelRatio
    );
    const state = sourceImage ? ImageState_default.IDLE : ImageState_default.EMPTY;
    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
    super(targetExtent, targetResolution, sourcePixelRatio, state);
    this.targetProj_ = targetProj;
    this.maxSourceExtent_ = maxSourceExtent;
    this.triangulation_ = triangulation;
    this.targetResolution_ = targetResolution;
    this.targetExtent_ = targetExtent;
    this.sourceImage_ = sourceImage;
    this.sourcePixelRatio_ = sourcePixelRatio;
    this.interpolate_ = interpolate;
    this.canvas_ = null;
    this.sourceListenerKey_ = null;
  }
  disposeInternal() {
    if (this.state == ImageState_default.LOADING) {
      this.unlistenSource_();
    }
    super.disposeInternal();
  }
  getImage() {
    return this.canvas_;
  }
  getProjection() {
    return this.targetProj_;
  }
  reproject_() {
    const sourceState = this.sourceImage_.getState();
    if (sourceState == ImageState_default.LOADED) {
      const width = getWidth(this.targetExtent_) / this.targetResolution_;
      const height = getHeight(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = render(
        width,
        height,
        this.sourcePixelRatio_,
        this.sourceImage_.getResolution(),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_
      );
    }
    this.state = sourceState;
    this.changed();
  }
  load() {
    if (this.state == ImageState_default.IDLE) {
      this.state = ImageState_default.LOADING;
      this.changed();
      const sourceState = this.sourceImage_.getState();
      if (sourceState == ImageState_default.LOADED || sourceState == ImageState_default.ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = listen(
          this.sourceImage_,
          EventType_default.CHANGE,
          function(e) {
            const sourceState2 = this.sourceImage_.getState();
            if (sourceState2 == ImageState_default.LOADED || sourceState2 == ImageState_default.ERROR) {
              this.unlistenSource_();
              this.reproject_();
            }
          },
          this
        );
        this.sourceImage_.load();
      }
    }
  }
  unlistenSource_() {
    unlistenByKey(
      this.sourceListenerKey_
    );
    this.sourceListenerKey_ = null;
  }
};
var Image_default2 = ReprojImage;

// node_modules/ol/source/Image.js
var ImageSourceEventType = {
  IMAGELOADSTART: "imageloadstart",
  IMAGELOADEND: "imageloadend",
  IMAGELOADERROR: "imageloaderror"
};
var ImageSourceEvent = class extends Event_default {
  constructor(type, image) {
    super(type);
    this.image = image;
  }
};
var ImageSource = class extends Source_default {
  constructor(options) {
    super({
      attributions: options.attributions,
      projection: options.projection,
      state: options.state,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true
    });
    this.on;
    this.once;
    this.un;
    this.resolutions_ = options.resolutions !== void 0 ? options.resolutions : null;
    this.reprojectedImage_ = null;
    this.reprojectedRevision_ = 0;
  }
  getResolutions() {
    return this.resolutions_;
  }
  findNearestResolution(resolution) {
    if (this.resolutions_) {
      const idx = linearFindNearest(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }
    return resolution;
  }
  getImage(extent, resolution, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }
      return this.getImageInternal(extent, resolution, pixelRatio, projection);
    } else {
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() && equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && equals(this.reprojectedImage_.getExtent(), extent)) {
          return this.reprojectedImage_;
        }
        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }
      this.reprojectedImage_ = new Image_default2(
        sourceProjection,
        projection,
        extent,
        resolution,
        pixelRatio,
        function(extent2, resolution2, pixelRatio2) {
          return this.getImageInternal(
            extent2,
            resolution2,
            pixelRatio2,
            sourceProjection
          );
        }.bind(this),
        this.getInterpolate()
      );
      this.reprojectedRevision_ = this.getRevision();
      return this.reprojectedImage_;
    }
  }
  getImageInternal(extent, resolution, pixelRatio, projection) {
    return abstract();
  }
  handleImageChange(event) {
    const image = event.target;
    let type;
    switch (image.getState()) {
      case ImageState_default.LOADING:
        this.loading = true;
        type = ImageSourceEventType.IMAGELOADSTART;
        break;
      case ImageState_default.LOADED:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADEND;
        break;
      case ImageState_default.ERROR:
        this.loading = false;
        type = ImageSourceEventType.IMAGELOADERROR;
        break;
      default:
        return;
    }
    if (this.hasListener(type)) {
      this.dispatchEvent(new ImageSourceEvent(type, image));
    }
  }
};
function defaultImageLoadFunction(image, src) {
  image.getImage().src = src;
}
var Image_default3 = ImageSource;

// node_modules/ol/source/ImageWMS.js
var DECIMALS = 4;
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];
var ImageWMS = class extends Image_default3 {
  constructor(options) {
    options = options ? options : {};
    super({
      attributions: options.attributions,
      interpolate: options.interpolate,
      projection: options.projection,
      resolutions: options.resolutions
    });
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.url_ = options.url;
    this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    this.params_ = Object.assign({}, options.params);
    this.v13_ = true;
    this.updateV13_();
    this.serverType_ = options.serverType;
    this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    this.image_ = null;
    this.imageSize_ = [0, 0];
    this.renderedRevision_ = 0;
    this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
  }
  getFeatureInfoUrl(coordinate, resolution, projection, params) {
    if (this.url_ === void 0) {
      return void 0;
    }
    const projectionObj = get(projection);
    const sourceProjectionObj = this.getProjection();
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = calculateSourceResolution(
        sourceProjectionObj,
        projectionObj,
        coordinate,
        resolution
      );
      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
    }
    const extent = getForViewAndSize(
      coordinate,
      resolution,
      0,
      GETFEATUREINFO_IMAGE_SIZE
    );
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    Object.assign(baseParams, this.params_, params);
    const x = floor((coordinate[0] - extent[0]) / resolution, DECIMALS);
    const y = floor((extent[3] - coordinate[1]) / resolution, DECIMALS);
    baseParams[this.v13_ ? "I" : "X"] = x;
    baseParams[this.v13_ ? "J" : "Y"] = y;
    return this.getRequestUrl_(
      extent,
      GETFEATUREINFO_IMAGE_SIZE,
      1,
      sourceProjectionObj || projectionObj,
      baseParams
    );
  }
  getLegendUrl(resolution, params) {
    if (this.url_ === void 0) {
      return void 0;
    }
    const baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params === void 0 || params["LAYER"] === void 0) {
      const layers = this.params_.LAYERS;
      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      const mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      const pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    Object.assign(baseParams, params);
    return appendParams(this.url_, baseParams);
  }
  getParams() {
    return this.params_;
  }
  getImageInternal(extent, resolution, pixelRatio, projection) {
    if (this.url_ === void 0) {
      return null;
    }
    resolution = this.findNearestResolution(resolution);
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    const imageResolution = resolution / pixelRatio;
    const center = getCenter(extent);
    const viewWidth = ceil(getWidth(extent) / imageResolution, DECIMALS);
    const viewHeight = ceil(getHeight(extent) / imageResolution, DECIMALS);
    const viewExtent = getForViewAndSize(center, imageResolution, 0, [
      viewWidth,
      viewHeight
    ]);
    const requestWidth = ceil(
      this.ratio_ * getWidth(extent) / imageResolution,
      DECIMALS
    );
    const requestHeight = ceil(
      this.ratio_ * getHeight(extent) / imageResolution,
      DECIMALS
    );
    const requestExtent = getForViewAndSize(center, imageResolution, 0, [
      requestWidth,
      requestHeight
    ]);
    const image = this.image_;
    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && containsExtent(image.getExtent(), viewExtent)) {
      return image;
    }
    const params = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_VERSION,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    Object.assign(params, this.params_);
    this.imageSize_[0] = round(
      getWidth(requestExtent) / imageResolution,
      DECIMALS
    );
    this.imageSize_[1] = round(
      getHeight(requestExtent) / imageResolution,
      DECIMALS
    );
    const url = this.getRequestUrl_(
      requestExtent,
      this.imageSize_,
      pixelRatio,
      projection,
      params
    );
    this.image_ = new Image_default(
      requestExtent,
      resolution,
      pixelRatio,
      url,
      this.crossOrigin_,
      this.imageLoadFunction_
    );
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(
      EventType_default.CHANGE,
      this.handleImageChange.bind(this)
    );
    return this.image_;
  }
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  getRequestUrl_(extent, size, pixelRatio, projection, params) {
    assert(this.url_ !== void 0, 9);
    params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case "geoserver":
          const dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params) {
            params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case "mapserver":
          params["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case "carmentaserver":
        case "qgis":
          params["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 8);
          break;
      }
    }
    params["WIDTH"] = size[0];
    params["HEIGHT"] = size[1];
    const axisOrientation = projection.getAxisOrientation();
    let bbox;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      bbox = [extent[1], extent[0], extent[3], extent[2]];
    } else {
      bbox = extent;
    }
    params["BBOX"] = bbox.join(",");
    return appendParams(this.url_, params);
  }
  getUrl() {
    return this.url_;
  }
  setImageLoadFunction(imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  }
  setUrl(url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  }
  updateParams(params) {
    Object.assign(this.params_, params);
    this.updateV13_();
    this.image_ = null;
    this.changed();
  }
  updateV13_() {
    const version = this.params_["VERSION"] || DEFAULT_VERSION;
    this.v13_ = compareVersions(version, "1.3") >= 0;
  }
};
var ImageWMS_default = ImageWMS;

export {
  defaultImageLoadFunction,
  Image_default3 as Image_default,
  ImageWMS_default
};
//# sourceMappingURL=chunk-UW7NNMT3.js.map
